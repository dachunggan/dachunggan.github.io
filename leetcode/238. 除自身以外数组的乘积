题目描述&示例：

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请不要使用除法，且在 O(n) 时间复杂度内完成此题。

 

示例 1:

输入: nums = [1,2,3,4]
输出: [24,12,8,6]
示例 2:

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
 

提示：

2 <= nums.length <= 105
-30 <= nums[i] <= 30
保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内
 

进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

=== 分割线 ===

思考&题解过程：

解1：
用除法，O(1)空间复杂度，O(n)时间复杂度的算法难度为入门级别：
两次遍历，第一次遍历求得数组所有元素乘积，并用一个变量将所有乘积记录，第二次遍历，将所有乘积变量除当前下标值，求得除自身元素外的元素乘积。

解2：
不用除法，O(n)时间复杂度的算法很容易想到：
一个额外数组，三次遍历。第一次从前到后遍历，额外数组依次存储下标之前的元素累乘结果；第二次从后到前遍历，输出数组依次存储下标之后的元素累乘结果；第三次遍历输出数组，由于已知当前下标之前的所有元素乘积与当前下标之后的元素乘积，两积相乘则未除自身外的所有元素乘积。

解3：
不用除法，O(1)空间复杂度，O(n)时间复杂度的算法得稍加思考：
由于输出数组不计算额外空间，所以基于解2思路，使用变量动态记录累积，则可以替代额外数组的使用，具体题解如下：
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int numsLen = nums.length;
        int[] ret = new int[nums.length];
        ret[numsLen - 1] = 1;
        for (int i = numsLen - 2; i >= 0; i --) {
            ret[i] = ret[i + 1] * nums[i + 1];
        }
        int tmp = nums[0];
        for (int i = 1; i < numsLen; i ++) {
            ret[i] = tmp * ret[i];
            tmp *= nums[i];
        }
        return ret;
    }
}

=== 分割线 ===
总结：
数组题出现顺序元素的情况时可考虑用变量动态记录的方式取代集合，以减小内存空间的使用。
